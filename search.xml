<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F28%2Fsql%20basic%2F</url>
    <content type="text"><![CDATA[title:SQL基础学习简单的总结（一）#SQL基础学习简单的总结（一） #数据库操作 建立一个新数据库：create database 数据库名 指定当前数据库：database 数据库名 关闭当前数据库：close database 数据库名 撤消一个数据库：drop database 数据库名 #基本表 ##基本表的定义（CREATE） create table 表名（ 列名 数据类型 [default 缺省值] [not null] [，列名 数据类型 [default 缺省值] [not null]] …… [，primary key（列名 [，列名] …）] [，foreign key （列名 [，列名] …） references 表名 （列名 [，列名] …）] [，check（条件）] ) 例： create table PROF ( PNO char(10), PNAME char(20) not null, SAL int, AGE int, DNO char(10), primary key (PNO), foreign key (DNO) references DEPT(DNO), check (SAL &gt; 0)) ##修改基本表定义（ALTER）格式： ALTER TABLE &lt;表名&gt; [ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] --增加新列 [ DROP &lt;列名、完整性约束名&gt; ] --删除列 [ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]； --修改列定义 ##撤消基本表定义（drop）格式： drop table 表名 ［RESTRICT| CASCADE］； RESTRICT：缺省，如果存在依赖该表的对象，则此表不能被删除CASCADE：在删除基本表的同时，相关的依赖对象一起删除 #索引 ##索引的定义格式: create [unique|distinct] [cluster] index 索引名 on 表名 (列名 [asc|desc] [ , 列名[asc|desc]]…) unique|distinct：唯一性索引，不允许表中不同的行在 索引列上取相同值。cluster：聚集索引，表中元组按索引项的值排序并物 理地聚集在一起。一个基本表上只能建一个聚集索引。asc|desc：索引表中索引值的排序次序，缺省为asc。 ###在最经常查询的列上建立聚簇索引以提高查询效率。 经常更新的列不宜建立聚簇索引。 ##索引的删除格式：drop index 索引名 #数据查询 ##单表查询 SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] … FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] … [ WHERE &lt;条件表达式&gt; ] [ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ] [ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]； ALL：缺省，显示结果不删除重复行 DISTINCT：显示结果删除重复行 ###更名运算：old_name as new_name(as可省略) ###Like四种匹配模式：1、%：表示任意0个或多个字符。可匹配任意类型和长度的字符。SELECT * FROM [user] WHERE u_name LIKE &#39;k%&#39; 2、_： 表示任意单个字符。匹配单个任意字符，它常用来限定表达式的字符长度语句：SELECT * FROM [user] WHERE u_name LIKE &#39;k_&#39; 3、[ ]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。SELECT * FROM [user] WHERE u_name LIKE &#39;[赵钱孙李]小明&#39; 4、[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。SELECT * FROM [user] WHERE u_name LIKE &#39;[^赵钱孙李]小明&#39; 定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符看待。可用\%去匹配 %，用\＿去匹配＿，用\ \去匹配 \LIKE &#39;DB\ Design&#39; ESCAPE &#39;\&#39;ESCAPE ‘＼’ 表示“ ＼” 为换码字符 ###order by排序order by 列名 [asc | desc]; 可以按一个或多个属性列排序升序：ASC；降序：DESC；缺省值为升序 ###聚集函数：计数 COUNT（[DISTINCT|ALL] *） COUNT（[DISTINCT|ALL] &lt;列名&gt;）计算总和 SUM（[DISTINCT|ALL] &lt;列名&gt;）计算平均值 AVG（[DISTINCT|ALL] &lt;列名&gt;）最大值 MAX（[DISTINCT|ALL] &lt;列名&gt;） &gt;最小值 MIN（[DISTINCT|ALL] &lt;列名例:计算1号课程的学生平均成绩。SELECT AVG(Grade) FROM SC WHERE Cno= &#39; 1 &#39;; ###group by分组group by 列名 [having 条件表达式]group by将表中的元组按指定一列或多列上的值相等的 原则分组，然后在每一分组上使用聚集函数，得到单一值。having则对分组进行选择，只将聚集函数作用到满足条件的分组上。例：列出所有课程均及格 的学生的平均成绩。 select SNO，avg(SCORE) from SC group by SNO having min(SCORE) &gt;= 60 ##连接查询 ###自然连接：两个表有同名的属性，此属性值相等的元组相连例: SELECT S.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade FROM S，SC WHERE S.Sno = SC.Sno ###自身连接：一个表与其自己进行连接,需要给表起别名以示区别,由于所有属性名都是同名属性，因此必须使用别名前缀例:查询每一门课的间接先修课（即先修课的先修课） SELECT FIRST.Cno，SECOND.Cpno FROM Course FIRST，Course SECOND WHERE FIRST.Cpno = SECOND.Cno ###外连接:自然连接时，可能会有信息因为失配而在结果中丢失，为避免丢失，可以假定往另一个参与连接的表中附加一个取值全为空值的行，失配的行会和空值行匹配，不至于丢失，称之为外连接。 外连接 = 自然连接 + 失配的元组[例]查询每个学生及其选修课程的情况 SELECT Student.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade FROM Student LEFT OUT JOIN SC ON (Student.Sno=SC.Sno) ###复合条件连接：WHERE子句中含多个连接条件例： SELECT S.Sno，Sname，Cname，Grade FROM S，SC，Course /*多表连接*/ WHERE S.Sno = SC.Sno and SC.Cno = Course.Cno； ####FROM S，SC，Course三者做相当于笛卡尔积 ##嵌套查询不相关子查询：子查询的查询条件不依赖于父查询，由里向外 逐层处理。即每个子查询在上一级查询处理 之前求解，子查询的结果用于建立其父查询的查找条件。相关子查询：子查询的查询条件依赖于父查询，首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表 然后再取外层表的下一个元组重复这一过程，直至外层表全部检查完为止。（有点像for循环） 不相关例子：查询与“刘晨”在同一个系学习的学生 SELECT Sno，Sname，Sdept FROM Student WHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname= ‘ 刘晨 ’); 相关例子：找出每个学生超过他选修课程平均成绩的课程号。 SELECT Sno,Cno FROM SC x /*更名 as可省略*/ WHERE Grade &gt;=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); ###带有ANY（SOME）或ALL谓词的子查询ANY：任意一个值ALL：所有值格式为：表达式 比较运算符 ANY|ALL （子查询）例：查询其他系中比计算机科学系所有学生年龄都小 的学生姓名及年龄。 SELECT Sname，Sage FROM S WHERE Sage &lt; ALL (SELECT Sage FROM S WHERE Sdept= &apos; CS &apos;) AND Sdept &lt;&gt; &apos; CS ’; ###带有EXISTS谓词的子查询例：查询所有选修了1号课程的学生姓名。 SELECT Sname FROM S WHERE EXISTS (SELECT * FROM SC WHERE Sno=S.Sno AND Cno= &apos; 1 &apos;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

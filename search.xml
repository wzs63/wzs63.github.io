<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM项目的配置和整体结构的总结]]></title>
    <url>%2F2019%2F03%2F16%2FSSM%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SpringSpring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 SpringMVCSpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。 mybatismybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。 关于配置：applicationContext.xml:设置连接数据库用的驱动，数据库名称，编码方式，账号密码。 &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--设置连接数据库用的驱动，数据库名称，编码方式，账号密码--&gt; &lt;property name=&quot;driverClassName&quot;&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;url&quot;&gt; &lt;value&gt;jdbc:mysql://127.0.0.1:3306/sjkdzy?characterEncoding=UTF-8&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;username&quot;&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 设置别名，自动扫描pojo下的类型，使得在后续配置文件xml中可以直接使用简单的别名，要不得写全名pojo.类名 &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;pojo&quot;/&gt;&lt;!--设置别名，自动扫描pojo下的类型，使得在后续配置文件xml中可以直接使用简单的别名，要不得写全名pojo.类名--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;!-- 对应上面配置的dataSource --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;!--指明映射xml的位置--&gt; &lt;/bean&gt; 指定自动扫描的mapper接口的包的位置 &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;mapper&quot;/&gt;&lt;!-- 扫描mapper类 --&gt; &lt;/bean&gt; springMVC.xml:设置自动扫描的controller，以便于用注解的方法表明哪些类是controller。 &lt;context:component-scan base-package=&quot;controller&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; 开启注解 &lt;mvc:annotation-driven /&gt; 设置jsp的默认路径，之后controller转的时候可以直接写jsp名， &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; 开放对上传功能的支持，我们的项目有上传头像的功能 &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;/&gt; Web.xml:配置spring &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 解决中文问题的过滤器 &lt;filter&gt; &lt;filter-name&gt;SetCharacterEncodingFilter&lt;/filter-name&gt; &lt;!-- 过滤器设置编码文件 --&gt; &lt;filter-class&gt;filter.SetCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- init-param元素定义了过滤器的初始化参数--&gt; &lt;description&gt;给参数和值设置名称和编码类型&lt;/description&gt; &lt;param-name&gt;encode&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;!-- filter-mapping告诉容器所有与模式向匹配的请求都应该允许通过访问控制过滤器。 所有以.action结尾的访问都先通过过滤器文件过滤 --&gt; &lt;filter-name&gt;SetCharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 配置springmvc &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 全部的结构 Controller：接收相应请求，执行相应方法，并转到相应页面以UserController为例：先用注解声明是 UserController一个Controller我们拦截所有.do的请求，UserController写关于user的请求，例如请求login.do,即登录，我们执行login方法，之后转到view层，即jsp页面，在登录完成后填完信息请求loginwc.do,将提取的信息进行验证，数据库里是否有uid为所填uid并且up为所填up的，若记录不为空，则登陆成功，此时我们将uid存入HttpSession中记录了用户登录状态，之后还要用这个数据 @Controller public class UserController { @Autowired UserService userService; @RequestMapping(&quot;login.do&quot;)//处理login.do这个请求 public ModelAndView login() { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;islogincg&quot;, 1); mav.setViewName(&quot;login&quot;); return mav; } @RequestMapping(&quot;loginwc.do&quot;)//处理loginwc.do这个请求 public ModelAndView loginwc(User user,HttpServletRequest req,HttpServletResponse resp) { ModelAndView mav = new ModelAndView(); System.out.println(user.getUid()); System.out.println(user.getUp()); if(userService.isCanLogin(user)) { req.getSession().setAttribute(&quot;uid&quot;, user.getUid()); String tximg = userService.selectByUid(user.getUid()).getTximg(); req.getSession().setAttribute(&quot;tximg&quot;, tximg); System.out.println(tximg); if(userService.isStore(user)) { req.getSession().setAttribute(&quot;isStore&quot;, 1); }else { req.getSession().setAttribute(&quot;isStore&quot;, 0); } req.getSession().setAttribute(&quot;tximg&quot;, &quot;mrtx.png&quot;); mav.setViewName(&quot;welcome&quot;); }else { mav.addObject(&quot;islogincg&quot;, 0); System.out.println(&quot;登录失败&quot;); mav.setViewName(&quot;login&quot;); } return mav; } } Mapper：用于操作数据库另外我们需要pojo来一一对应我们的数据库的表 我们将相应的SQL语句写到mapper的xml中 &lt;mapper namespace=&quot;mapper.CommodityMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity and cs != 0 &lt;/select&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Commodity&quot; &gt; insert into commodity(cname,cs,cp,uid,type) values (#{cname},#{cs},#{cp},#{uid},#{type}) &lt;/insert&gt; &lt;select id=&quot;selectByUid&quot; parameterType=&quot;String&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where uid = &apos;${_parameter}&apos; and cs != 0 &lt;/select&gt; &lt;select id=&quot;selectByType&quot; parameterType=&quot;_int&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where type = ${_parameter} and cs != 0 &lt;/select&gt; &lt;select id=&quot;selectByLikeCname&quot; parameterType=&quot;map&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where cname like &apos;%${part}%&apos; and cs != 0 order by cid asc limit ${first},6 &lt;/select&gt; &lt;select id=&quot;selectByCid&quot; parameterType=&quot;_int&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where cid = ${_parameter} and cs != 0 &lt;/select&gt; &lt;select id=&quot;selectByYeShu&quot; parameterType=&quot;map&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where cs != 0 and type = ${type} order by cid asc limit ${first},6 &lt;/select&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;_int&quot;&gt; delete from commodity where cid = ${_parameter} &lt;/delete&gt; &lt;update id=&quot;updateCs&quot; parameterType=&quot;map&quot;&gt; update commodity set cs=#{cs} where cid=#{cid} &lt;/update&gt; &lt;/mapper&gt; 在同一个包中写相应mapper接口，每个方法都对应xml的语句id，同一个包下自动对应，之后方便对数据库操作 package mapper; import java.util.List; import java.util.Map; import pojo.Commodity; import pojo.Purchase; public interface CommodityMapper { void add(Commodity c); List&lt;Commodity&gt; selectAll(); List&lt;Commodity&gt; selectByUid(String uid); List&lt;Commodity&gt; selectByType(int type); List&lt;Commodity&gt; selectByLikeCname(Map&lt;String, Object&gt; map); List&lt;Commodity&gt; selectByCid(int cid); List&lt;Commodity&gt; selectByYeShu(Map&lt;String, Integer&gt; map); void delete(int cid); void updateCs(Map&lt;String,Integer&gt; map); } Service：相对具体的业务逻辑服务层public interface CommodityService { void add(Commodity c); List&lt;Commodity&gt; selectAll(); List&lt;Commodity&gt; selectByUid(String uid); List&lt;Commodity&gt; selectByType(int type); List&lt;Commodity&gt; selectByLikeCname(String part,int first); List&lt;Commodity&gt; selectByCid(int cid); List&lt;Commodity&gt; selectByYeShu(int type,int first); void delete(int cid); void updateCs(int cs,int cid); } ###ServiceImpl: Service实现类(持有自动注入的mapper对象以便操作数据库) @Service(&quot;CommodityService&quot;) public class CommodityServiceImpl implements CommodityService{ @Autowired CommodityMapper commodityMapper; @Override public void add(Commodity c) { commodityMapper.add(c); } @Override public List&lt;Commodity&gt; selectAll() { return commodityMapper.selectAll(); } @Override public List&lt;Commodity&gt; selectByUid(String uid) { return commodityMapper.selectByUid(uid); } public List&lt;Commodity&gt; selectByType(int type){ return commodityMapper.selectByType(type); } public List&lt;Commodity&gt; selectByLikeCname(String part,int first){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;part&quot;, part); map.put(&quot;first&quot;, first); return commodityMapper.selectByLikeCname(map); } public List&lt;Commodity&gt; selectByCid(int cid){ return commodityMapper.selectByCid(cid); } @Override public List&lt;Commodity&gt; selectByYeShu(int type, int first) { Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;type&quot;, type); map.put(&quot;first&quot;, first); return commodityMapper.selectByYeShu(map); } @Override public void delete(int cid) { commodityMapper.delete(cid); } @Override public void updateCs(int cs, int cid) { Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;cs&quot;, cs); map.put(&quot;cid&quot;, cid); commodityMapper.updateCs(map); } } Filter：实现拦截请求，将请求的编码设为utf-8,以至于支持中文 public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { // TODO Auto-generated method stub //转换 HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)resp; /* * 判断在web.xml文件中是否配置了编码格式的信息 * 如果为空，则设置编码格式为配置文件中的编码格式 * 否则编码格式设置为utf-8 */ if(this.encode != null &amp;&amp; !this.encode.equals(&quot;&quot;)){ request.setCharacterEncoding(this.encode); response.setCharacterEncoding(this.encode); }else{ request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); } /* * 使用doFilter方法调用链中的下一个过滤器或目标资源（servlet或JSP页面）。 * chain.doFilter处理过滤器的其余部分（如果有的话），最终处理请求的servlet或JSP页面。 */ chain.doFilter(request, response); } Page:用于分页的实现 public class Page&lt;T&gt; { int first; // 开始数据 int count; // 每一页的数量 int total; // 总共的数据量 private List&lt;T&gt; list;//当前页的数据 public Page() { } public Page(int first, int count) { super(); this.first = first; this.count = count; } 相关jar包：]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC总结]]></title>
    <url>%2F2018%2F11%2F26%2FJDBC%2F</url>
    <content type="text"><![CDATA[java对关系数据库的支持是通过JDBC(Java DateBase Connectivity)API来提供的。 2018.12.14修改：SqlServer连接时：“jdbc:sqlserver://localhost:1433;DatabaseName=数据库名,与MySQL连接不同（不仅仅是端口号）。 JDBC的使用分为以下几个步骤：一、初始化驱动1234567891011try &#123; //以连接mysql为例 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //若要连接SqlServer，对应初始化驱动类为&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot; //若是Oracle数据库，则为&quot;oracle.jdbc.driver.OracleDriver&quot; //数据库驱动加载成功 &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 初始化驱动类com.mysql.jdbc.Driver在相关包中,若未引入包，Class.forName(“com.mysql.jdbc.Driver”)会抛出ClassNotFoundException异常。 二、建立数据库连接连接需要提供以下信息：DBMS服务器所运行的机器的主机名:127.0.0.1或者localhost (本机)，数据库的端口号，用来侦听进入的连接： 3306 （mysql专用端口号）或者1433（SqlServer专用端口号）,或者1521（Oracle专用端口号），希望连接的数据库名称，编码方式，如UTF-8（可选），账号 ，密码 。 JDBC中的数据库连接是通过Connection类的实例来表示的，这个类的实例由DriverManager类的静态方法getConnection()返回。12345678910111213141516try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 建立与数据库的Connection连接 Connection c = DriverManager.getConnection( &quot;jdbc:mysql://127.0.0.1:3306/数据库名称?characterEncoding=UTF-8&quot;, &quot;账号&quot;, &quot;密码&quot;); //连接成功，c为获取连接对象 &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 三、创建Statement实例Statement是用于执行SQL命令的接口。创建一个Statement或其子接口之一（PreparedStatement接口或者CallablesStatement接口）的实例。可以通过调用Connection的createStatement()方法来创建Statement的实例1234567891011121314151617try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager .getConnection(&quot;jdbc:mysql://127.0.0.1:3306/数据库名称?characterEncoding=UTF-8&quot;, &quot;用户名&quot;, &quot;密码&quot;); // 注意：使用的是 java.sql.Statement， 不要不小心使用到： com.mysql.jdbc.Statement Statement s = c.createStatement(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 四、利用Statement实例执行SQL命令Statement实例执行方法：executeUpdata()方法int executeUpdate(String sql)执行给定的SQL语句，这可能是 INSERT ， UPDATE ，或 DELETE语句，或者不返回任何内容，如SQL DDL语句的SQL语句。返回类型为int，表示所更改的行数。 executeQuery()方法ResultSet executeQuery(String sql)当希望执行查询时（SELECT语句）可使用executeQuery()方法。执行给定的SQL语句，该语句返回单个 ResultSet对象，用来处理查询的结果。 execute()方法boolean execute(String sql)此方法可能会返回多个更新数或者ResultSet实例。如果第一个返回值是ResultSet则返回true如果第一个返回值是int则发布会false可以使用方法getResultSet或getUpdateCount检索结果，然后getMoreResults移动到任何后续结果。（getUpdateCount返回值为-1就会到达结果队列的尾部）123456789101112131415161718try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager .getConnection(&quot;jdbc:mysql://127.0.0.1:3306/数据库名称?characterEncoding=UTF-8&quot;,&quot;用户名&quot;, &quot;密码&quot;); Statement s = c.createStatement(); // 注意： 字符串要用单引号&apos; String sql = &quot;insert into tableName values(&apos;value&apos;)&quot;; s.execute(sql); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; ResultSet介绍1.光标定位boolean next() throws SQLException将光标从当前位置向前移动一行。 1234ResultSet rs = s.executeQuery(SELECT * FROM TABLE1);while(rs.next())&#123; //do something...&#125; 光标最初位于第一行之前; 第一次调用方法next使第一行成为当前行; 第二个调用使第二行成为当前行，依此类推。当返回false时，光标位于最后一行之后。 boolean relative(int rows) throws SQLException将光标移动到正或负的相对行数。调用relative(0)是有效的，但不会更改光标位置。 2.数据检索getXXX()，例如String getString(int columnIndex) throws SQLException这个检索的当前行中指定列的值，索引从1开始。12//从第二列检索String值columnValue = rs.getString(2); 根据属性名检索，例如String getString(String columnLabel) throws SQLException3.数值修改updateXXX(),insertXXX(),deleteXXX() PreparedStatement介绍PreparedStatement是Statement类的一个子类有时候需要执行的SQL语句相似，仅仅是通过某个参数而区分。那么编译每一个SQL语句会使得性能变差。 PreparedStatement可以使得这样的SQL语句只编译一次（预编译机制），执行多次，使用可改变的参数来修改执行的SQL语句，使得性能更好。12345String sql = &quot;insert into table1 values(?,?)&quot;;PreparedStatement ps = c.prepareStatement(sql);ps.setString(1, &quot;value&quot;);//设置参数从一开始ps.setInt(2, 123);ps.execute(); 注意：PreparedStatement设置参数时，从1开始。另外，PreparedStatement不需要字符串拼接，而是参数设置，所以还有防止SQL注入式攻击功能。 五、最后关闭连接，释放资源先关闭Statement后关闭Connection1234567891011121314151617finally &#123; if (s != null) try &#123; s.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (c != null) try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 事务在事务中的多个操作，要么都成功，要么都失败通过 c.setAutoCommit(false);关闭自动提交使用 c.commit();进行手动提交12345678c.setAutoCommit(false);//提交前发生了错误，则rollbackString sql1 = &quot;update...&quot;;s.execute(sql1);String sql2 = &quot;updata...&quot;;s.execute(sql2);// 手动提交c.commit(); 参考书籍：Java高级编程（第二版）。参考网站：how2j]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据统计每一天/每一周发邮件的数量，并用可视化软件实现可视化。]]></title>
    <url>%2F2018%2F11%2F15%2Fsjycl2%2F</url>
    <content type="text"><![CDATA[下载对公众开放的安然(Enron)公司的电子邮件数据集。下载地址： http://www.ahschulz.de/enron-email-data/； 将数据导入数据库（message表含有date字段表示发送邮件时间。Mid表示编号），根据date进行分组，统计每一组的mid的数量（即这一天邮箱数量）。执行以下SQL语句，将每天/每周（换为weekofyear即可）数据导入Excel（因为之后利用plot.ly进行数据可视化时感觉CSV格式更方便些） 123select date,count(mid) from message group by dayofyear(date) into outfile &quot;F:\day_apps.csv&quot; FIELDS TERMINATED BY &apos;,&apos;; （注：FIELDS TERMINATED BY ‘,’; 靠‘，’分隔字段，如果没有这个语句date和count（mid）数据会导入到一个格子中）数据库中分组查看结果：每天：每周： 利用plot.ly进行数据可视化每天的发送邮件统计：每周的发送邮件统计：]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用Python从json数据集提取出the Growlers的所有音乐的歌名]]></title>
    <url>%2F2018%2F11%2F15%2Fsjycl%2F</url>
    <content type="text"><![CDATA[json数据集下载地址：http://itunes.apple.com/search?term=the-growlers 提取歌名并放入MySQL数据库中先在MySQL数据库中创建相应数据库和表 123456 create database yvchuli create table music( trackName varchar(60) ) 利用Python提取数据集中的歌名，并连接MySQL数据库，存入数据12345678910111213141516171819202122import json import pymysql.cursors#连接mysql数据库connection = pymysql.Connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, password=&apos;123456&apos;, db=&apos;yvchuli&apos;, charset=&apos;utf8&apos;)with open(&apos;1.txt&apos;) as f: date = json.load(f)list = date[&quot;results&quot;]# 获取游标cursor = connection.cursor()for item in list: #插入数据 sql = &quot;INSERT INTO music VALUES (\&quot;%s\&quot;)&quot; data = item[&apos;trackName&apos;] print(data) cursor.execute(sql % data) connection.commit() MySQL数据库储存结果： 另外，也可以提取数据存放入Excel12345678910111213141516171819202122import json import pymysql.cursors#连接mysql数据库connection = pymysql.Connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, password=&apos;123456&apos;, db=&apos;yvchuli&apos;, charset=&apos;utf8&apos;)with open(&apos;1.txt&apos;) as f: date = json.load(f)list = date[&quot;results&quot;]# 获取游标cursor = connection.cursor()for item in list: #插入数据 sql = &quot;INSERT INTO music VALUES (\&quot;%s\&quot;)&quot; data = item[&apos;trackName&apos;] print(data) cursor.execute(sql % data) connection.commit() 注：若不加newline=’’，每行数据都会有空行 加newline=’’后变正常： If newline=’’ is not specified, newlines embedded inside quoted fields will not be interpreted correctly, and on platforms that use \r\n linendings on write an extra \r will be added. It should always be safe to specify newline=’’, since the csv module does its own (universal) newline handling.– python参考手册]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2F2018%2F10%2F29%2Fsql%2F</url>
    <content type="text"><![CDATA[title:SQL基础学习简单的总结（一）SQL基础学习简单的总结（一）数据库操作建立一个新数据库：create database 数据库名 指定当前数据库：database 数据库名 关闭当前数据库：close database 数据库名 撤消一个数据库：drop database 数据库名 基本表基本表的定义（CREATE）create table 表名（ 列名 数据类型 [default 缺省值] [not null] [，列名 数据类型 [default 缺省值] [not null]] …… [，primary key（列名 [，列名] …）] [，foreign key （列名 [，列名] …） references 表名 （列名 [，列名] …）] [，check（条件）] ) 例： create table PROF ( PNO char(10), PNAME char(20) not null, SAL int, AGE int, DNO char(10), primary key (PNO), foreign key (DNO) references DEPT(DNO), check (SAL &gt; 0)) 修改基本表定义（ALTER）格式： ALTER TABLE &lt;表名&gt; [ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] --增加新列 [ DROP &lt;列名、完整性约束名&gt; ] --删除列 [ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]; --修改列定义 撤消基本表定义（drop）格式： drop table 表名 ［RESTRICT| CASCADE］; RESTRICT：缺省，如果存在依赖该表的对象，则此表不能被删除CASCADE：在删除基本表的同时，相关的依赖对象一起删除 索引索引的定义格式: create [unique|distinct] [cluster] index 索引名 on 表名 (列名 [asc|desc] [ , 列名[asc|desc]]…) unique|distinct：唯一性索引，不允许表中不同的行在 索引列上取相同值。cluster：聚集索引，表中元组按索引项的值排序并物 理地聚集在一起。一个基本表上只能建一个聚集索引。asc|desc：索引表中索引值的排序次序，缺省为asc。 在最经常查询的列上建立聚簇索引以提高查询效率。 经常更新的列不宜建立聚簇索引。索引的删除格式：drop index 索引名 数据查询单表查询SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] … FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] … [ WHERE &lt;条件表达式&gt; ] [ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ] [ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]; ALL：缺省，显示结果不删除重复行 DISTINCT：显示结果删除重复行 更名运算：old_name as new_name(as可省略) Like四种匹配模式：1、%：表示任意0个或多个字符。可匹配任意类型和长度的字符。SELECT * FROM [user] WHERE u_name LIKE &#39;k%&#39; 2、_： 表示任意单个字符。匹配单个任意字符，它常用来限定表达式的字符长度语句：SELECT * FROM [user] WHERE u_name LIKE &#39;k_&#39; 3、[ ]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。SELECT * FROM [user] WHERE u_name LIKE &#39;[赵钱孙李]小明&#39; 4、[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。SELECT * FROM [user] WHERE u_name LIKE &#39;[^赵钱孙李]小明&#39; 定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符看待。可用\%去匹配 %，用\＿去匹配＿，用\ \去匹配 \LIKE &#39;DB\ Design&#39; ESCAPE &#39;\&#39;ESCAPE ‘＼’ 表示“ ＼” 为换码字符 order by排序order by 列名 [asc | desc]; 可以按一个或多个属性列排序升序：ASC 降序：DESC 缺省值为升序 聚集函数：计数 COUNT（[DISTINCT|ALL] *） COUNT（[DISTINCT|ALL] &lt;列名&gt;）计算总和 SUM（[DISTINCT|ALL] &lt;列名&gt;）计算平均值 AVG（[DISTINCT|ALL] &lt;列名&gt;）最大值 MAX（[DISTINCT|ALL] &lt;列名&gt;） &gt;最小值 MIN（[DISTINCT|ALL] &lt;列名例:计算1号课程的学生平均成绩。SELECT AVG(Grade) FROM SC WHERE Cno= &#39; 1 &#39;; group by分组group by 列名 [having 条件表达式]group by将表中的元组按指定一列或多列上的值相等的 原则分组，然后在每一分组上使用聚集函数，得到单一值。having则对分组进行选择，只将聚集函数作用到满足条件的分组上。例：列出所有课程均及格 的学生的平均成绩。 select SNO，avg(SCORE) from SC group by SNO having min(SCORE) &gt;= 60 连接查询自然连接：两个表有同名的属性，此属性值相等的元组相连例: SELECT S.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade FROM S，SC WHERE S.Sno = SC.Sno 自身连接：一个表与其自己进行连接,需要给表起别名以示区别,由于所有属性名都是同名属性，因此必须使用别名前缀例:查询每一门课的间接先修课（即先修课的先修课） SELECT FIRST.Cno，SECOND.Cpno FROM Course FIRST，Course SECOND WHERE FIRST.Cpno = SECOND.Cno 外连接:自然连接时，可能会有信息因为失配而在结果中丢失，为避免丢失，可以假定往另一个参与连接的表中附加一个取值全为空值的行，失配的行会和空值行匹配，不至于丢失，称之为外连接。 外连接 = 自然连接 + 失配的元组例:查询每个学生及其选修课程的情况 SELECT Student.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade FROM Student LEFT OUT JOIN SC ON (Student.Sno=SC.Sno); 复合条件连接：WHERE子句中含多个连接条件例： SELECT S.Sno，Sname，Cname，Grade FROM S，SC，Course /*多表连接*/ WHERE S.Sno = SC.Sno and SC.Cno = Course.Cno; FROM S，SC，Course三者做相当于笛卡尔积嵌套查询不相关子查询：子查询的查询条件不依赖于父查询，由里向外 逐层处理。即每个子查询在上一级查询处理 之前求解，子查询的结果用于建立其父查询的查找条件。相关子查询：子查询的查询条件依赖于父查询，首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表 然后再取外层表的下一个元组重复这一过程，直至外层表全部检查完为止。（有点像for循环） 不相关例子：查询与“刘晨”在同一个系学习的学生 SELECT Sno，Sname，Sdept FROM Student WHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname= ‘ 刘晨 ’); 相关例子：找出每个学生超过他选修课程平均成绩的课程号。 SELECT Sno,Cno FROM SC x /*更名 as可省略*/ WHERE Grade &gt;=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); 带有ANY（SOME）或ALL谓词的子查询ANY：任意一个值ALL：所有值格式为：表达式 比较运算符 ANY|ALL （子查询）例：查询其他系中比计算机科学系所有学生年龄都小 的学生姓名及年龄。 SELECT Sname，Sage FROM S WHERE Sage &lt; ALL (SELECT Sage FROM S WHERE Sdept= &apos; CS &apos;) AND Sdept &lt;&gt; &apos; CS ’; 带有EXISTS谓词的子查询例：查询所有选修了1号课程的学生姓名。 SELECT Sname FROM S WHERE EXISTS (SELECT * FROM SC WHERE Sno=S.Sno AND Cno= &apos; 1 &apos;);]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java集合笔记]]></title>
    <url>%2F2019%2F03%2F27%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[接口总览 Iterable接口:实现此接口允许对象成为“for-each loop”语句的目标。所以集合都可以用foreach遍历访问 Collection接口：主要方法：boolean add(E element)Iterator iterator()//返回一个实现了Iterator接口的对象，作为Java迭代器 一些实用方法 Iterator接口主要方法E next()boolean hasNext()void remove() Java迭代器在两个元素之间，刚开始在在第一个元素之前，next()方法越过后面的元素并返回这个元素。越过所有元素后，迭代器后面无元素，hasNext返回falseremove()和next()需绑定使用，next()越过元素后再remove()删除这个元素例：输出两个相邻元素 it.remove(); it.next(); it.remove();//不写next()会报IllegalStateException异常 Queue接口(先进先出，头部减，尾部加)主要方法：void add(E element)E remove()int size()实现方式1.循环队列（不循环容易假溢出）：实现类–ArrayDeque2.链表:实现类–LinkedList List接口,有序集合，所以可以使用索引来获取元素主要方法void add(E element)void add(E element, int index)void remove(int position)void remove(E element)//删除第一次出现E get(int index)E set(int index,E element) 实现方式1.数组，很适合随机访问：ArrayList（和Vector类的区别是Vector方法都是同步）2.链表，最好用迭代器访问，随机访问很慢:ListedListps:Java中所有链表结构都是双向链表，即不仅有next，还有previous前驱节点 ListedList的listIterator方法返回了一个实现了ListLterator接口的迭代器对象 ListLterator接口主要方法void add(E element)//在迭代器位置前加元素，因为有集合（Set是无序的，所以Lterator接口没有add方法）E previous()boolean hasPrevious()后两个方法可以用来反向遍历链表 Set接口不允许添加重复的元素，hashCode方法要确保两个元素相同的Set对应相同的散列码实现方式HashSet类，无序，基于散列表，contains方法重新定义为在对应的桶中寻找ps:散列表：每个对象都有一个散列码，对应某个桶，桶中若有多个对象（即散列冲突，新对象会先和桶中所有对象比较是否一样）则以链表形式排列。一般来讲装填因子（对象数/桶数)=0.75正好。TreeSet类:有序,排序基于红黑树，每次添加元素都会调整树的结构，新对象和树节点比较，放到正确位置。所有元素要能比较，即实现了Comparable接口。 Map接口（键值对，减唯一，相当于Python的字典）主要方法V get(Object key）V put(K key,V value)实现类HashMap无序TreeMap有序基于红黑树（Red-Black tree）的 NavigableMap 实现,元素得能比较遍历key（Set keySet()） for (String key : map.keySet()) {//keySet()返回key组成的Set //dosomething } 遍历value(Collection&lt;K,V&gt; entrySet()) for (String value : map.values()) { //dosomething } 遍历键值(Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()) for (Map.Entry&lt;String,String&gt; entry : map.entrySet()) { System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue()); } 根据键排序TreeMap默认根据key升序排列，改变为降序： Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;( new Comparator&lt;String&gt;() { public int compare(String obj1, String obj2) { // 降序排序 return obj2.compareTo(obj1); } }); 根据值排序(HashMap也可以) //按照value排序 List&lt;Map.Entry&lt;String, Integer&gt;&gt; entryArrayList = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(entryArrayList, new Comparator&lt;Entry&lt;String, Integer&gt;&gt;() { //降序 public int compare(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2) { return o2.getValue().compareTo(o1.getValue()); } }); Map&lt;String,Integer&gt; map2 = new HashMap&lt;&gt;(); for (Map.Entry&lt;String, Integer&gt; entry : entryArrayList) { //dosomething with entry.getKey(), entry.getValue() } 实现类总览 –《Java技术核心 卷一》集合章节笔记]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[springMVC笔记]]></title>
    <url>%2F2019%2F03%2F25%2FspringMVC%2F</url>
    <content type="text"><![CDATA[MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 负责显示数据，这个部分多为前端应用，而 Controller 会有一个机制将处理的结果 (可能是 Model, 集合或是状态等) 交给 View，然后由 View 来决定怎么显示模型（Model） - 负责数据访问,掌管数据源 DispatcherServlet是springMVC的入口（所有的请求都提交到该Servlet）springmvc自带有org.springframework.web.servlet.DispatcherServlet充当调度员的一个servlet，拦截匹配的请求，并且依据相应的规则分发到目标Controller来处理。 配置及整体过程web.xml下的配置&lt;!-- spring mvc核心：分发servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 设置在web应用启动时就将此servlet创建并初始化（默认值为0，就是在用对应请求到来时才创建） &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 此servlet初始化时会找一个WEB-INF目录下的一个配置文件，命名规则为servletName-servlet.xml（比如对于 mvc-dispatcher默认是找WEB-INF\mvc-dispatcher-servlet.xml配置文件）。当然这个配置文件路径和名字可以自己设置 &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; 这样直接把springMVC.xml放src目录下就可以了 拦截使用为*.do的请求： &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; springMVC.xml（Spring MVC的 映射配置文件）&lt;beans&gt; &lt;bean id=&quot;simpleUrlHandlerMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;/hello.do&quot;&gt;HelloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;helloController&quot; class=&quot;controller.HelloController&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 访问路径/hello.do会交给id=helloController的bean处理 创建控制类控制类 helloController实现接口Controller ，提供方法处理请求 public class HelloController implements Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response)throws Exception { ModelAndView mav = new ModelAndView(&quot;hello.jsp&quot;);//跳转到这个页面 mav.addObject(&quot;message&quot;, &quot;Hello Spring MVC&quot;);//JSP中可用&lt;h1&gt;${message}&lt;/h1&gt; return mav; } } WebContent目录下创建hello.jsp，可以用喜欢的方式展示数据（ ${message}）例如： &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt; &lt;h1&gt;${message}&lt;/h1&gt; 这样一来在用户请求/hello.do时，因为web.xml中的配置 *.do的所有请求都经过DispatcherServlet，再根据配置文件springMVC.xml ，访问路径/hello.do对应HelloController类，在HelloController中指定跳转到页面hello.jsp，并传递message数据，最后在hello.jsp中显示message信息。 视图定位&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; 这样一来把视图约定在 /WEB-INF/page/*.jsp 这个位置sController中写 ModelAndView mav = new ModelAndView(“hello”)，就是跳转到/WEB-INF/jsp/hello.jsp了 用注释的方式@Controller 表示该类是一个控制器@RequestMapping(“register.do”) 表示此请求会映射到此方法 @Controller public class UserController { @Autowired UserService userService; @RequestMapping(&quot;register.do&quot;) public ModelAndView register(){ ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;register&quot;); return mav; } } springMVC.xml需要添加以下内容1.声明spring-context部分 &lt;beans ...... xmlns:context=&quot;http://www.springframework.org/schema/context&quot; ...... &gt; 2.指定扫描注释的包，把类放到这个包下面并加以@Controller注释就会知道这是个控制器类 &lt;context:component-scan base-package=&quot;controller&quot; /&gt; 表单提交并自动将数据注入对象pojo包下建User类 package pojo; public class User { String uid; String uname; String up; public String getUid() { return uid; } public void setUid(String uid) { this.uid = uid; } public String getUname() { return uname; } public void setUname(String uname) { this.uname = uname; } public String getUp() { return up; } public void setUid(String uid){ this.up = up; } public float getUb() { return ub; } public User(){ } } 表单中，要填的两项分别为name=”uid”，name=”up” 与User类setUid(String uid)，setUid(String uid)对应 &lt;form action=&quot;loginwc.do&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;账户&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;uid&quot; placeholder=&quot;用户名/手机&quot; class=&quot;form-control&quot; style=&quot;width:300px&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;up&quot; placeholder=&quot;密码&quot; class=&quot;form-control&quot; style=&quot;width:300px&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; 对应Controllerspringmvc发现页面传递过来有参数uid的时候，同时检测到参数的User这个类有setUid方法，那么就会把参数uid的值，注入到这个user对象里去了(up同理） @RequestMapping(&quot;loginwc.do&quot;) public ModelAndView loginwc(User user,HttpServletRequest req,HttpServletResponse resp) { ModelAndView mav = new ModelAndView(); System.out.println(user.getUid());//就是表单输入的值 System.out.println(user.getUp());//就是表单输入的值 //dosomething return mav; } 另外也可以用@RequestParam注释直接提取表单的数据到方法参数中(当然不一定是非要是String了，springMVC 会尽力转化的) public ModelAndView loginwc(@RequestParam String uid,@RequestParam String up,) { ModelAndView mav = new ModelAndView(); System.out.println(user.getUid());//就是表单输入的值 System.out.println(user.getUp());//就是表单输入的值 //dosomething return mav; } 字段不同名也可以设置value值 @RequestParam(value=””) public ModelAndView loginwc(@RequestParam(value=&quot;uid&quot;) String userId,@RequestParam(value=&quot;uid&quot;) String userPassword,) 请求重定向redirect:@RequestMapping(&quot;/jump.do&quot;) public ModelAndView jump() { ModelAndView mav = new ModelAndView(&quot;redirect:/hello.do&quot;); return mav; } 页面上传springMVC.xml新增加一段配置，开放对上传功能的支持 &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;/&gt; upload.jsp 上传页面上传页面，需要注意的是form 的两个属性必须提供method=”post” 和 enctype=”multipart/form-data” 缺一不可上传组件 增加一个属性 accept=”image/*” 表示只能选择图片进行上传 &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; import=&quot;java.util.*&quot; isELIgnored=&quot;false&quot;%&gt; &lt;form action=&quot;uploadImage.do&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 选择图片:&lt;input type=&quot;file&quot; name=&quot;image&quot; accept=&quot;image/*&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt; pojo.UploadedImageFile public class UploadedImageFile { MultipartFile image; public MultipartFile getImage() { return image; } public void setImage(MultipartFile image) { this.image = image; } } 之后编写uploadImage.do请求对应的controller的方法对图片进行操作（保存展示等）。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Session和Cookie]]></title>
    <url>%2F2019%2F03%2F24%2FSession%E5%92%8Ccookie%2F</url>
    <content type="text"><![CDATA[HTTP协议是无状态连接，一次请求响应后即断开，多次请求之间互相不知道对方。（即连接只为一个请求响应存在）那怎么才能知道哪几个请求是来自于同一个客户呢（记录客户）？会话（session）原理机制：在客户第一次请求时，容器为此客户生成一个唯一会话ID，并且随响应返回给客户，客户在请求时会带上这个会话ID，容器看到这个会话ID后会找与之匹配的会话和此次请求相关联。（会话ID须存于服务器） 那客户服务器两端通过什么交流会话ID呢？用cookie（就是用于客户和服务器交换的一小段数据（一个名/值String对））容器负责生生成会话ID–&gt;创建cookie对象–&gt;将会话ID放于cookie中–&gt;把cookie设为响应的一部分。ps:为什么不用客户IP地址识别客户呢？因为对于服务器来说，客户的IP地址是路由的地址，所以这个客户和在这个网络的所有客户的IP地址一样，无法唯一识别。 在浏览器选项中清除所有Cookie之后再访问，即第一次请求,响应有Set-Cookie。（ps:因为此请求对应的servlet用到了session对象（即getSession（）调用），所以才会有Set-Cookie。如果没有用到session对象就没有Set-Cookie，当然之后再请求也没有Cookie了。）之后再请求一次请求多了cookie项，内容就是之前响应的set-cookie 因为服务器找到了客户对应的会话，所以不用新建会话，此时响应没有了set-cookie。 如何得到session对象？request.getSession() 如果之前没有这个客户对应的会话，会新建一个，有的话返回之前的session。 如何判断session是否是新建的呢？request.getSession().isNew() 如果完全不想创建新的会话呢？request.getSession(false) 当然这样有可能会为null 如果客户不支持cookie呢？最后一条后路–URL重写（encodeURL()）容器在发现用getSesion调用，请求却没有cookie时（可能是第一次请求也可能是不支持cookie），会同时尝试cookie和URL重写两种方法。因为容器不会知道客户是否不支持cookie。没有会话，每一次请求响应直接没有关系（HTTP无状态），容器不会知道自己是不是对这个客户使用过cookie。 如何结束一个会话？三种方法1.超时web.xml设置，单位为分钟 &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt; 如果要设置某个session request.getSession().setMaxInactiveInterval(15*60);//15分钟 2.invalidate()方法 request.getSession().invalidate(); 3.应用结束 但是cookie可以活的更长！默认会话结束后，cookie会消失。但是也可以设置让cookie继续活下去。在一个星期后再发出请求，此时虽然会话已到期，客户还存着cookie。服务器还是可以识别到是之前那个客户。]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JAVA只有值传递]]></title>
    <url>%2F2019%2F03%2F23%2FJava%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[JAVA只有值传递值传递即方法传入的是拷贝（比如传入string，就是传入string对象的引用的拷贝），所以交换什么的，没有用。 ps：引用传递传入的就是对象的地址，不必再开内存空间，即传入方法的对象就是自己，当然会随之改变了。企图用方法直接交换int、交换String(未交换成功) public static void main(String[] args) { int a=1;11 int b=2; String str1=&quot;str1&quot;; String str2=&quot;str2&quot;; System.out.println(&quot;交换前&quot;); System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); System.out.println(&quot;str1:&quot;+str1); System.out.println(&quot;str2:&quot;+str2); change(a, b); change(str1, str2); System.out.println(&quot;交换后&quot;); System.out.println(&quot;a:&quot;+a); System.out.println(&quot;b:&quot;+b); System.out.println(&quot;str1:&quot;+str1); System.out.println(&quot;str2:&quot;+str2); } public static void change(int a,int b) { int c=0; c=a; a=b; b=c; } public static void change(String str1,String str2) { String str3; str3=str1; str1=str2; str2=str3; } 控制台输出 那到底怎么能用方法进行String交换呢？可以将String转为stringbuffer（这个才是参数），利用此类的方法将引用的对象的属性（值）改变，最后交换结束再赋值给原来的String。不过总感觉意义不大。ps:int通过Integer.parseInt()方法也可以同理转换。 public static void main(String[] args) { String str1=&quot;str1&quot;; String str2=&quot;str2&quot;; System.out.println(&quot;交换前&quot;); System.out.println(&quot;str1:&quot;+str1); System.out.println(&quot;str2:&quot;+str2); StringBuffer strbf1=new StringBuffer(str1); StringBuffer strbf2=new StringBuffer(str2); change(strbf1, strbf2); str1=strbf1.toString(); str2=strbf2.toString(); System.out.println(&quot;交换后&quot;); System.out.println(&quot;str1:&quot;+str1); System.out.println(&quot;str2:&quot;+str2); } public static void change(StringBuffer strbf1,StringBuffer strbf2) { StringBuffer strbf3= new StringBuffer(); strbf3.append(strbf1); strbf1.delete(0, strbf1.length()-1);//清空str1 strbf1.append(strbf2); strbf2.delete(0, strbf2.length()-1);//清空str2 strbf2.append(strbf3); } } 控制台输出]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[failed to load the jni shared library报错]]></title>
    <url>%2F2019%2F03%2F23%2Fbug1%2F</url>
    <content type="text"><![CDATA[打开eclipse报错failed to load the jni shared library，经上网搜索知道了是jdk和eclipse位数不匹配。想起上午为了运用一个软件被迫安装了新的jdk是32位，所以在环境变量中将path新添加的jdk路径全部删除，并将控制面板中的Java设置为只开启那个64位的jdk之后再看jdk版本为64位之后查看eclipse文件夹下eclipse.ini文件 可以看出eclipse是64位（32位的话x86后无_64）jdk和eclipse位数一致了，但是打开eclipse依旧报同样的错。之后重启了电脑，eclipse运行正常了。]]></content>
      <categories>
        <category>一些bug</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java web学习笔记（一）]]></title>
    <url>%2F2019%2F03%2F22%2FJava-web%2F</url>
    <content type="text"><![CDATA[TomcatApache开发的Servlet容器，实现了对Servlet和JSP的支持,并且内含了一个HTTP服务器。tomcat容器模型其中Context容器直接管理Servlet在容器中的包装类Wrapper,并且一个Context容器对应一个web项目 启动Tomcat方式一：运行apache-tomcat-version\bin\startup.bat启动shutdown.bat关闭。ps:如果闪退应该是JDK环境变量没配置好 方法二：可以在eclipse中添加服务器，之后run就可以了 Tomcat默认端口号为8080，开启后访问http://localhost:8080/出现 Apache Tomcat页面则为开启成功。 ps:开启时如果提醒端口被占用，可通过命令netstat -ano|findstr 8080查询占用进程的pid，任务管理器中关闭即可，或者也可以改Tomcat的端口。 web应用初始化web应用初始化在ContextConfig的configureStart方法中实现。初始化的任务主要是解析web.xml文件（描述了整个web应用的关键信息，是整个web应用的入口）。过程：Tomcat找globalWebXml-&gt;找hostWebXml-&gt;找WEB-INF/web.xml-&gt;将web.xml中的配置项解析为相应属性放入WebXml对象中-&gt;将WebXml对象的属性设置到Context容器中（这一步将Servlet包装成StandardWrapper,作为子容器存于Context容器中。除了创建servlet对象外还创建了filter和listener） Servlet生命周期加载和实例化创建servelet实例：web.xml中配置load-on-startup&gt;0时服务器启动时就创建，load-on-startup=0（即默认）第一次请求该servlet时才创建无论访问了多少次Servlet，构造方法 只会执行一次，所以Servlet是单实例的 初始化执行初始化方法init(ServletConfig conf)，将包装了StandardWrapper对象的StandardWrapperFacade作为ServletConfig对象传入方法。 请求处理servlet对象去处理客户端请求，在service(ServletRequest req，ServletResponse res)方法中执行，URL映射到servlet容器的工作由org.apache.tomcat.util.http.mapper类完成。mapper在request进入container容器之前就更加URL将host和context容器存入request的mappingData属性中，以至于使request知道要访问哪一个子容器 销毁该Servlet所在的web应用重新启动或者Tomcat关闭时执行destroy()方法。 创建servlet创建类，继承HttpServlet类即可主要用的方法doGet（处理get请求，即直接输入URL的访问方式）和doPost（处理post请求，多为表单提交的方式）需根据需求覆写 public class ServletName extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //doSometing } } 在xml中配置servlet-name：servlet名字，可随意定义servlet-class：servlet的实际路径url-pattern：对应的请求URL映射配置 &lt;servlet&gt; &lt;servlet-name&gt;showImg&lt;/servlet-name&gt; &lt;servlet-class&gt;com.zr.controller.ImgController&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;showImg&lt;/servlet-name&gt; &lt;url-pattern&gt;/getImg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; URL映射两大原则1.精确匹配如servlet1为/index.html,servlet2为/*,请求URL为http:/localhost:8080/项目名/index.html,则匹配到第一个。 2.最长路径匹配无法精确匹配情况下使用，如servlet1为/ind/,servlet2为/,请求URL为http:/localhost:8080/项目名/index.html,则匹配到第一个。 注释配URL置映射也可以在类上加注释@WebServlet(name=”…”,urlPatterns=”/…”) 之后访问http://localhost:8080/项目名/配置的urlPatterns就可以将请求发送到刚刚配置的servlet了。 ServletConfig、ServletRequest、ServletResponse(这三个都是通过容器传给servlet的)、ServletContextServletConfig在servlet初始化时就传给了servlet获取途径：getServletConfig();主要方法：getServletName(); //获取servlet的名称，也就是我们在web.xml中配置的servlet-namegetServletContext(); //获取ServletContext对象getInitParameter(String); //获取在servlet中初始化参数的值。getInitParameterNames(); //获取在Servlet中所有初始化参数的名字 ServletContext对象获取途径：getServletContext()一个web项目，就存在一个ServletContext实例，在tomcat在启动时创建，服务器关闭时销毁，每个Servlet读可以访问到它。getAttribute(String name)setAttribute(String name, Object obj)removeAttribute(String name)getServletContext().getRealPath(“”)//获取项目绝对路径 ServletRequest、ServletResponse：请求到达时容器传给servlet常用方法request.getRequestURL(): 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI(): 浏览器发出请求的资源名部分，去掉了协议和主机名”request.getQueryString(): 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr(): 浏览器所处于的客户机的IP地址request.getRemoteHost(): 浏览器所处于的客户机的主机名request.getRemotePort(): 浏览器所处于的客户机使用的网络端口request.getLocalAddr(): 服务器的IP地址request.getLocalName(): 服务器的主机名request.getMethod(): 得到客户机请求方式一般是GET或者POSTrequest.getHeader() 获取浏览器传递过来的头信息。request.getHeaderNames() 获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 response.setContentType(“text/html; charset=UTF-8”);//不仅发送到浏览器的内容会使用UTF-8编码，而且还通知浏览器使用UTF-8编码方式进行显示。所以总能正常显示中文 response.setCharacterEncoding(“UTF-8”); //仅仅是发送的浏览器的内容是UTF-8编码的，至于浏览器是用哪种编码方式显示不管。 所以当浏览器的显示编码方式不是UTF-8的时候，就会看到乱码，需要手动再进行一次设置。 设置不用缓存response.setDateHeader(“Expires”,0 );response.setHeader(“Cache-Control”,”no-cache”);response.setHeader(“pragma”,”no-cache”); 请求转发request.getRequestDispatcher(String path).forward(request,response); path:转发后跳转的页面，这里不管用不用”/“开头，都是以web项目根开始，请求转发只局限与在同一个web项目下使用。 重定向方式一：手动方案response.setStatus(302); //状态码302就代表重定向response.setHeader(“location”,”http://www.baidu.com&quot;);方式二：使用封装好的，通过response.sendRedirect(“http://www.baidu.com&quot;); 请求转发和重定向的区别forward（转发）：客户浏览器发送http请求–&gt;web服务器接受此请求–&gt;调用内部的一个方法在容器内部完成请求处理和转发动作–&gt;将目标资源发送给客户。转发的路径必须是同一个web容器下的url,在客户浏览器地址栏还是原来的地址，也就是说客户是感觉不到服务器做了转发的。转发跳转过程是在服务器实现,浏览器只做了一次访问请求。 redirect（重定向）：客户浏览器发送http请求–&gt;web服务器接受后发送302状态码响应及对应新的location给客户浏览器–&gt;客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址–&gt;服务器根据此请求寻找资源并发送给客户。可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示新地址。重定向行为是浏览器做了至少两次的访问请求的。(转发是服务器行为，重定向是客户端行为。) Listener监听器 按监听的对象划分，可以分为 ServletContext对象监听器HttpSession对象监听器ServletRequest对象监听器 接口ServletContextListener监听当前web应用的初始化public void contextInitialized(ServletContextEvent arg0)监听当前web应用的销毁public void contextDestroyed(ServletContextEvent arg0) 接口ServletContextAttributeListener监听属性的增加public void attributeAdded(ServletContextAttributeEvent e)监听属性的移除public void attributeRemoved(ServletContextAttributeEvent e)监听属性的替换public void attributeReplaced(ServletContextAttributeEvent e) 接口HttpSessionListener 监听session创建sessionCreated()监听session销毁sessionDestroyed() 接口HttpSessionAttributeListenersession中增加属性时attributeAdded()session中移除属性时attributeRemoved()替换session中的属性时attributeReplaced() 接口 ServletRequestListener和ServletRequestAttributeListener 创建了一个Request的时候触发requestInitialized()当本次请求结束的时候触发requestDestroyed()当有新增属性时触发attributeAdded()当有替换属性时触发attributeReplaced()当有移除属性时触发attributeRemoved() web.xml中配置listener &lt;listener&gt; &lt;listener-class&gt;listener类路径&lt;/listener-class&gt; &lt;/listener&gt; 利用listener统计在线人数，即监听session创建和销毁。 public class OnlineNumberListener implements HttpSessionListener { @Override public void sessionCreated(HttpSessionEvent e) { ServletContext application = e.getSession().getServletContext(); Integer online_number = (Integer) application.getAttribute(&quot;online_number&quot;); if (null == online_number) online_number = 0; online_number++; application.setAttribute(&quot;online_number&quot;, online_number); System.out.println(&quot;新增一位在线用户&quot;); } @Override public void sessionDestroyed(HttpSessionEvent e) { ServletContext application = e.getSession().getServletContext(); Integer online_number = (Integer) application.getAttribute(&quot;online_number&quot;); if(null==online_number){ online_number = 0; } else online_number--; application.setAttribute(&quot;online_number&quot;, online_number); System.out.println(&quot;一位用户离线&quot;); } } web.xml配置： &lt;listener&gt; &lt;listener-class&gt;listener.OnlineNumberListener&lt;/listener-class&gt; &lt;/listener&gt; Filter过滤器截取用户端的请求和响应信息，并对这些信息进行过滤Filter会随着tomcat的启动自启动。 新建filter实现Filter接口即可 public class FilterName implements Filter { @Override public void destroy() { } @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) //dosomething } @Override public void init(FilterConfig arg0) throws ServletException { } } web.xml配置 &lt;filter&gt; &lt;filter-name&gt;Filter&lt;/filter-name&gt; &lt;filter-class&gt;filter.Filter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 利用filter解决中文编码问题 public class SetCharacterEncodingFilter implements Filter { //存储编码格式信息 private String encode = null; @Override public void destroy() { // TODO Auto-generated method stub } @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { // TODO Auto-generated method stub //转换 HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)resp; /* * 判断在web.xml文件中是否配置了编码格式的信息 * 如果为空，则设置编码格式为配置文件中的编码格式 * 否则编码格式设置为utf-8 */ if(this.encode != null &amp;&amp; !this.encode.equals(&quot;&quot;)){ request.setCharacterEncoding(this.encode); response.setCharacterEncoding(this.encode); }else{ request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); } /* * 使用doFilter方法调用链中的下一个过滤器或目标资源（servlet或JSP页面）。 * chain.doFilter处理过滤器的其余部分（如果有的话），最终处理请求的servlet或JSP页面。 */ chain.doFilter(request, response); } @Override public void init(FilterConfig arg0) throws ServletException { // TODO Auto-generated method stub this.encode=arg0.getInitParameter(&quot;encode&quot;); System.out.println(&quot;this.encode:&quot;+encode); } } web.xml配置： &lt;!-- 过滤器配置信息 --&gt; &lt;filter&gt; &lt;filter-name&gt;SetCharacterEncodingFilter&lt;/filter-name&gt; &lt;!-- 过滤器设置编码文件 --&gt; &lt;filter-class&gt;filter.SetCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- init-param元素定义了过滤器的初始化参数--&gt; &lt;description&gt;给参数和值设置名称和编码类型&lt;/description&gt; &lt;param-name&gt;encode&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;!-- filter-mapping告诉容器所有与模式向匹配的请求都应该允许通过访问控制过滤器。 所有以.action结尾的访问都先通过过滤器文件过滤 --&gt; &lt;filter-name&gt;SetCharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt;]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSM项目的配置和整体结构的总结]]></title>
    <url>%2F2019%2F03%2F16%2FSSM%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SpringSpring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 SpringMVCSpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。 mybatismybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。 关于配置：applicationContext.xml:设置连接数据库用的驱动，数据库名称，编码方式，账号密码。 &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;!--设置连接数据库用的驱动，数据库名称，编码方式，账号密码--&gt; &lt;property name=&quot;driverClassName&quot;&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;url&quot;&gt; &lt;value&gt;jdbc:mysql://127.0.0.1:3306/sjkdzy?characterEncoding=UTF-8&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;username&quot;&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;123456&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 设置别名，自动扫描pojo下的类型，使得在后续配置文件xml中可以直接使用简单的别名，要不得写全名pojo.类名 &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;pojo&quot;/&gt;&lt;!--设置别名，自动扫描pojo下的类型，使得在后续配置文件xml中可以直接使用简单的别名，要不得写全名pojo.类名--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;!-- 对应上面配置的dataSource --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;&lt;!--指明映射xml的位置--&gt; &lt;/bean&gt; 指定自动扫描的mapper接口的包的位置 &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;mapper&quot;/&gt;&lt;!-- 扫描mapper类 --&gt; &lt;/bean&gt; springMVC.xml:设置自动扫描的controller，以便于用注解的方法表明哪些类是controller。 &lt;context:component-scan base-package=&quot;controller&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; 开启注解 &lt;mvc:annotation-driven /&gt; 设置jsp的默认路径，之后controller转的时候可以直接写jsp名， &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; 开放对上传功能的支持，我们的项目有上传头像的功能 &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;/&gt; Web.xml:配置spring &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; 解决中文问题的过滤器 &lt;filter&gt; &lt;filter-name&gt;SetCharacterEncodingFilter&lt;/filter-name&gt; &lt;!-- 过滤器设置编码文件 --&gt; &lt;filter-class&gt;filter.SetCharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- init-param元素定义了过滤器的初始化参数--&gt; &lt;description&gt;给参数和值设置名称和编码类型&lt;/description&gt; &lt;param-name&gt;encode&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;!-- filter-mapping告诉容器所有与模式向匹配的请求都应该允许通过访问控制过滤器。 所有以.action结尾的访问都先通过过滤器文件过滤 --&gt; &lt;filter-name&gt;SetCharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 配置springmvc &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- spring mvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 全部的结构 Controller：接收相应请求，执行相应方法，并转到相应页面以UserController为例：先用注解声明是 UserController一个Controller我们拦截所有.do的请求，UserController写关于user的请求，例如请求login.do,即登录，我们执行login方法，之后转到view层，即jsp页面，在登录完成后填完信息请求loginwc.do,将提取的信息进行验证，数据库里是否有uid为所填uid并且up为所填up的，若记录不为空，则登陆成功，此时我们将uid存入HttpSession中记录了用户登录状态，之后还要用这个数据 @Controller public class UserController { @Autowired UserService userService; @RequestMapping(&quot;login.do&quot;)//处理login.do这个请求 public ModelAndView login() { ModelAndView mav = new ModelAndView(); mav.addObject(&quot;islogincg&quot;, 1); mav.setViewName(&quot;login&quot;); return mav; } @RequestMapping(&quot;loginwc.do&quot;)//处理loginwc.do这个请求 public ModelAndView loginwc(User user,HttpServletRequest req,HttpServletResponse resp) { ModelAndView mav = new ModelAndView(); System.out.println(user.getUid()); System.out.println(user.getUp()); if(userService.isCanLogin(user)) { req.getSession().setAttribute(&quot;uid&quot;, user.getUid()); String tximg = userService.selectByUid(user.getUid()).getTximg(); req.getSession().setAttribute(&quot;tximg&quot;, tximg); System.out.println(tximg); if(userService.isStore(user)) { req.getSession().setAttribute(&quot;isStore&quot;, 1); }else { req.getSession().setAttribute(&quot;isStore&quot;, 0); } req.getSession().setAttribute(&quot;tximg&quot;, &quot;mrtx.png&quot;); mav.setViewName(&quot;welcome&quot;); }else { mav.addObject(&quot;islogincg&quot;, 0); System.out.println(&quot;登录失败&quot;); mav.setViewName(&quot;login&quot;); } return mav; } } Mapper：用于操作数据库另外我们需要pojo来一一对应我们的数据库的表 我们将相应的SQL语句写到mapper的xml中 &lt;mapper namespace=&quot;mapper.CommodityMapper&quot;&gt; &lt;select id=&quot;selectAll&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity and cs != 0 &lt;/select&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Commodity&quot; &gt; insert into commodity(cname,cs,cp,uid,type) values (#{cname},#{cs},#{cp},#{uid},#{type}) &lt;/insert&gt; &lt;select id=&quot;selectByUid&quot; parameterType=&quot;String&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where uid = &apos;${_parameter}&apos; and cs != 0 &lt;/select&gt; &lt;select id=&quot;selectByType&quot; parameterType=&quot;_int&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where type = ${_parameter} and cs != 0 &lt;/select&gt; &lt;select id=&quot;selectByLikeCname&quot; parameterType=&quot;map&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where cname like &apos;%${part}%&apos; and cs != 0 order by cid asc limit ${first},6 &lt;/select&gt; &lt;select id=&quot;selectByCid&quot; parameterType=&quot;_int&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where cid = ${_parameter} and cs != 0 &lt;/select&gt; &lt;select id=&quot;selectByYeShu&quot; parameterType=&quot;map&quot; resultType=&quot;Commodity&quot;&gt; select * from commodity where cs != 0 and type = ${type} order by cid asc limit ${first},6 &lt;/select&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;_int&quot;&gt; delete from commodity where cid = ${_parameter} &lt;/delete&gt; &lt;update id=&quot;updateCs&quot; parameterType=&quot;map&quot;&gt; update commodity set cs=#{cs} where cid=#{cid} &lt;/update&gt; &lt;/mapper&gt; 在同一个包中写相应mapper接口，每个方法都对应xml的语句id，同一个包下自动对应，之后方便对数据库操作 package mapper; import java.util.List; import java.util.Map; import pojo.Commodity; import pojo.Purchase; public interface CommodityMapper { void add(Commodity c); List&lt;Commodity&gt; selectAll(); List&lt;Commodity&gt; selectByUid(String uid); List&lt;Commodity&gt; selectByType(int type); List&lt;Commodity&gt; selectByLikeCname(Map&lt;String, Object&gt; map); List&lt;Commodity&gt; selectByCid(int cid); List&lt;Commodity&gt; selectByYeShu(Map&lt;String, Integer&gt; map); void delete(int cid); void updateCs(Map&lt;String,Integer&gt; map); } Service：相对具体的业务逻辑服务层public interface CommodityService { void add(Commodity c); List&lt;Commodity&gt; selectAll(); List&lt;Commodity&gt; selectByUid(String uid); List&lt;Commodity&gt; selectByType(int type); List&lt;Commodity&gt; selectByLikeCname(String part,int first); List&lt;Commodity&gt; selectByCid(int cid); List&lt;Commodity&gt; selectByYeShu(int type,int first); void delete(int cid); void updateCs(int cs,int cid); } ###ServiceImpl: Service实现类(持有自动注入的mapper对象以便操作数据库) @Service(&quot;CommodityService&quot;) public class CommodityServiceImpl implements CommodityService{ @Autowired CommodityMapper commodityMapper; @Override public void add(Commodity c) { commodityMapper.add(c); } @Override public List&lt;Commodity&gt; selectAll() { return commodityMapper.selectAll(); } @Override public List&lt;Commodity&gt; selectByUid(String uid) { return commodityMapper.selectByUid(uid); } public List&lt;Commodity&gt; selectByType(int type){ return commodityMapper.selectByType(type); } public List&lt;Commodity&gt; selectByLikeCname(String part,int first){ Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;part&quot;, part); map.put(&quot;first&quot;, first); return commodityMapper.selectByLikeCname(map); } public List&lt;Commodity&gt; selectByCid(int cid){ return commodityMapper.selectByCid(cid); } @Override public List&lt;Commodity&gt; selectByYeShu(int type, int first) { Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;type&quot;, type); map.put(&quot;first&quot;, first); return commodityMapper.selectByYeShu(map); } @Override public void delete(int cid) { commodityMapper.delete(cid); } @Override public void updateCs(int cs, int cid) { Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;cs&quot;, cs); map.put(&quot;cid&quot;, cid); commodityMapper.updateCs(map); } } Filter：实现拦截请求，将请求的编码设为utf-8,以至于支持中文 public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException { // TODO Auto-generated method stub //转换 HttpServletRequest request = (HttpServletRequest)req; HttpServletResponse response = (HttpServletResponse)resp; /* * 判断在web.xml文件中是否配置了编码格式的信息 * 如果为空，则设置编码格式为配置文件中的编码格式 * 否则编码格式设置为utf-8 */ if(this.encode != null &amp;&amp; !this.encode.equals(&quot;&quot;)){ request.setCharacterEncoding(this.encode); response.setCharacterEncoding(this.encode); }else{ request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); } /* * 使用doFilter方法调用链中的下一个过滤器或目标资源（servlet或JSP页面）。 * chain.doFilter处理过滤器的其余部分（如果有的话），最终处理请求的servlet或JSP页面。 */ chain.doFilter(request, response); } Page:用于分页的实现 public class Page&lt;T&gt; { int first; // 开始数据 int count; // 每一页的数量 int total; // 总共的数据量 private List&lt;T&gt; list;//当前页的数据 public Page() { } public Page(int first, int count) { super(); this.first = first; this.count = count; } 相关jar包：]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JDBC总结]]></title>
    <url>%2F2018%2F11%2F26%2FJDBC%2F</url>
    <content type="text"><![CDATA[java对关系数据库的支持是通过JDBC(Java DateBase Connectivity)API来提供的。 2018.12.14修改：SqlServer连接时：“jdbc:sqlserver://localhost:1433;DatabaseName=数据库名,与MySQL连接不同（不仅仅是端口号）。 JDBC的使用分为以下几个步骤：一、初始化驱动1234567891011try &#123; //以连接mysql为例 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //若要连接SqlServer，对应初始化驱动类为&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot; //若是Oracle数据库，则为&quot;oracle.jdbc.driver.OracleDriver&quot; //数据库驱动加载成功 &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 初始化驱动类com.mysql.jdbc.Driver在相关包中,若未引入包，Class.forName(“com.mysql.jdbc.Driver”)会抛出ClassNotFoundException异常。 二、建立数据库连接连接需要提供以下信息：DBMS服务器所运行的机器的主机名:127.0.0.1或者localhost (本机)，数据库的端口号，用来侦听进入的连接： 3306 （mysql专用端口号）或者1433（SqlServer专用端口号）,或者1521（Oracle专用端口号），希望连接的数据库名称，编码方式，如UTF-8（可选），账号 ，密码 。 JDBC中的数据库连接是通过Connection类的实例来表示的，这个类的实例由DriverManager类的静态方法getConnection()返回。12345678910111213141516try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); // 建立与数据库的Connection连接 Connection c = DriverManager.getConnection( &quot;jdbc:mysql://127.0.0.1:3306/数据库名称?characterEncoding=UTF-8&quot;, &quot;账号&quot;, &quot;密码&quot;); //连接成功，c为获取连接对象 &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 三、创建Statement实例Statement是用于执行SQL命令的接口。创建一个Statement或其子接口之一（PreparedStatement接口或者CallablesStatement接口）的实例。可以通过调用Connection的createStatement()方法来创建Statement的实例1234567891011121314151617try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager .getConnection(&quot;jdbc:mysql://127.0.0.1:3306/数据库名称?characterEncoding=UTF-8&quot;, &quot;用户名&quot;, &quot;密码&quot;); // 注意：使用的是 java.sql.Statement， 不要不小心使用到： com.mysql.jdbc.Statement Statement s = c.createStatement(); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; 四、利用Statement实例执行SQL命令Statement实例执行方法：executeUpdata()方法int executeUpdate(String sql)执行给定的SQL语句，这可能是 INSERT ， UPDATE ，或 DELETE语句，或者不返回任何内容，如SQL DDL语句的SQL语句。返回类型为int，表示所更改的行数。 executeQuery()方法ResultSet executeQuery(String sql)当希望执行查询时（SELECT语句）可使用executeQuery()方法。执行给定的SQL语句，该语句返回单个 ResultSet对象，用来处理查询的结果。 execute()方法boolean execute(String sql)此方法可能会返回多个更新数或者ResultSet实例。如果第一个返回值是ResultSet则返回true如果第一个返回值是int则发布会false可以使用方法getResultSet或getUpdateCount检索结果，然后getMoreResults移动到任何后续结果。（getUpdateCount返回值为-1就会到达结果队列的尾部）123456789101112131415161718try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Connection c = DriverManager .getConnection(&quot;jdbc:mysql://127.0.0.1:3306/数据库名称?characterEncoding=UTF-8&quot;,&quot;用户名&quot;, &quot;密码&quot;); Statement s = c.createStatement(); // 注意： 字符串要用单引号&apos; String sql = &quot;insert into tableName values(&apos;value&apos;)&quot;; s.execute(sql); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; ResultSet介绍1.光标定位boolean next() throws SQLException将光标从当前位置向前移动一行。 1234ResultSet rs = s.executeQuery(SELECT * FROM TABLE1);while(rs.next())&#123; //do something...&#125; 光标最初位于第一行之前; 第一次调用方法next使第一行成为当前行; 第二个调用使第二行成为当前行，依此类推。当返回false时，光标位于最后一行之后。 boolean relative(int rows) throws SQLException将光标移动到正或负的相对行数。调用relative(0)是有效的，但不会更改光标位置。 2.数据检索getXXX()，例如String getString(int columnIndex) throws SQLException这个检索的当前行中指定列的值，索引从1开始。12//从第二列检索String值columnValue = rs.getString(2); 根据属性名检索，例如String getString(String columnLabel) throws SQLException3.数值修改updateXXX(),insertXXX(),deleteXXX() PreparedStatement介绍PreparedStatement是Statement类的一个子类有时候需要执行的SQL语句相似，仅仅是通过某个参数而区分。那么编译每一个SQL语句会使得性能变差。 PreparedStatement可以使得这样的SQL语句只编译一次（预编译机制），执行多次，使用可改变的参数来修改执行的SQL语句，使得性能更好。12345String sql = &quot;insert into table1 values(?,?)&quot;;PreparedStatement ps = c.prepareStatement(sql);ps.setString(1, &quot;value&quot;);//设置参数从一开始ps.setInt(2, 123);ps.execute(); 注意：PreparedStatement设置参数时，从1开始。另外，PreparedStatement不需要字符串拼接，而是参数设置，所以还有防止SQL注入式攻击功能。 五、最后关闭连接，释放资源先关闭Statement后关闭Connection1234567891011121314151617finally &#123; if (s != null) try &#123; s.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (c != null) try &#123; c.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 事务在事务中的多个操作，要么都成功，要么都失败通过 c.setAutoCommit(false);关闭自动提交使用 c.commit();进行手动提交12345678c.setAutoCommit(false);//提交前发生了错误，则rollbackString sql1 = &quot;update...&quot;;s.execute(sql1);String sql2 = &quot;updata...&quot;;s.execute(sql2);// 手动提交c.commit(); 参考书籍：Java高级编程（第二版）。参考网站：how2j]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据统计每一天/每一周发邮件的数量，并用可视化软件实现可视化。]]></title>
    <url>%2F2018%2F11%2F15%2Fsjycl2%2F</url>
    <content type="text"><![CDATA[下载对公众开放的安然(Enron)公司的电子邮件数据集。下载地址： http://www.ahschulz.de/enron-email-data/； 将数据导入数据库（message表含有date字段表示发送邮件时间。Mid表示编号），根据date进行分组，统计每一组的mid的数量（即这一天邮箱数量）。执行以下SQL语句，将每天/每周（换为weekofyear即可）数据导入Excel（因为之后利用plot.ly进行数据可视化时感觉CSV格式更方便些） 123select date,count(mid) from message group by dayofyear(date) into outfile &quot;F:\day_apps.csv&quot; FIELDS TERMINATED BY &apos;,&apos;; （注：FIELDS TERMINATED BY ‘,’; 靠‘，’分隔字段，如果没有这个语句date和count（mid）数据会导入到一个格子中）数据库中分组查看结果：每天：每周： 利用plot.ly进行数据可视化每天的发送邮件统计：每周的发送邮件统计：]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用Python从json数据集提取出the Growlers的所有音乐的歌名]]></title>
    <url>%2F2018%2F11%2F15%2Fsjycl%2F</url>
    <content type="text"><![CDATA[json数据集下载地址：http://itunes.apple.com/search?term=the-growlers 提取歌名并放入MySQL数据库中先在MySQL数据库中创建相应数据库和表 123456 create database yvchuli create table music( trackName varchar(60) ) 利用Python提取数据集中的歌名，并连接MySQL数据库，存入数据12345678910111213141516171819202122import json import pymysql.cursors#连接mysql数据库connection = pymysql.Connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, password=&apos;123456&apos;, db=&apos;yvchuli&apos;, charset=&apos;utf8&apos;)with open(&apos;1.txt&apos;) as f: date = json.load(f)list = date[&quot;results&quot;]# 获取游标cursor = connection.cursor()for item in list: #插入数据 sql = &quot;INSERT INTO music VALUES (\&quot;%s\&quot;)&quot; data = item[&apos;trackName&apos;] print(data) cursor.execute(sql % data) connection.commit() MySQL数据库储存结果： 另外，也可以提取数据存放入Excel12345678910111213141516171819202122import json import pymysql.cursors#连接mysql数据库connection = pymysql.Connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, password=&apos;123456&apos;, db=&apos;yvchuli&apos;, charset=&apos;utf8&apos;)with open(&apos;1.txt&apos;) as f: date = json.load(f)list = date[&quot;results&quot;]# 获取游标cursor = connection.cursor()for item in list: #插入数据 sql = &quot;INSERT INTO music VALUES (\&quot;%s\&quot;)&quot; data = item[&apos;trackName&apos;] print(data) cursor.execute(sql % data) connection.commit() 注：若不加newline=’’，每行数据都会有空行 加newline=’’后变正常： If newline=’’ is not specified, newlines embedded inside quoted fields will not be interpreted correctly, and on platforms that use \r\n linendings on write an extra \r will be added. It should always be safe to specify newline=’’, since the csv module does its own (universal) newline handling.– python参考手册]]></content>
      <categories>
        <category>数据处理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2F2018%2F10%2F29%2Fsql%2F</url>
    <content type="text"><![CDATA[title:SQL基础学习简单的总结（一）SQL基础学习简单的总结（一）数据库操作建立一个新数据库：create database 数据库名 指定当前数据库：database 数据库名 关闭当前数据库：close database 数据库名 撤消一个数据库：drop database 数据库名 基本表基本表的定义（CREATE）create table 表名（ 列名 数据类型 [default 缺省值] [not null] [，列名 数据类型 [default 缺省值] [not null]] …… [，primary key（列名 [，列名] …）] [，foreign key （列名 [，列名] …） references 表名 （列名 [，列名] …）] [，check（条件）] ) 例： create table PROF ( PNO char(10), PNAME char(20) not null, SAL int, AGE int, DNO char(10), primary key (PNO), foreign key (DNO) references DEPT(DNO), check (SAL &gt; 0)) 修改基本表定义（ALTER）格式： ALTER TABLE &lt;表名&gt; [ ADD &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] --增加新列 [ DROP &lt;列名、完整性约束名&gt; ] --删除列 [ ALTER COLUMN&lt;列名&gt; &lt;数据类型&gt; ]; --修改列定义 撤消基本表定义（drop）格式： drop table 表名 ［RESTRICT| CASCADE］; RESTRICT：缺省，如果存在依赖该表的对象，则此表不能被删除CASCADE：在删除基本表的同时，相关的依赖对象一起删除 索引索引的定义格式: create [unique|distinct] [cluster] index 索引名 on 表名 (列名 [asc|desc] [ , 列名[asc|desc]]…) unique|distinct：唯一性索引，不允许表中不同的行在 索引列上取相同值。cluster：聚集索引，表中元组按索引项的值排序并物 理地聚集在一起。一个基本表上只能建一个聚集索引。asc|desc：索引表中索引值的排序次序，缺省为asc。 在最经常查询的列上建立聚簇索引以提高查询效率。 经常更新的列不宜建立聚簇索引。索引的删除格式：drop index 索引名 数据查询单表查询SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [，&lt;目标列表达式&gt;] … FROM &lt;表名或视图名&gt;[， &lt;表名或视图名&gt; ] … [ WHERE &lt;条件表达式&gt; ] [ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ] [ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ]; ALL：缺省，显示结果不删除重复行 DISTINCT：显示结果删除重复行 更名运算：old_name as new_name(as可省略) Like四种匹配模式：1、%：表示任意0个或多个字符。可匹配任意类型和长度的字符。SELECT * FROM [user] WHERE u_name LIKE &#39;k%&#39; 2、_： 表示任意单个字符。匹配单个任意字符，它常用来限定表达式的字符长度语句：SELECT * FROM [user] WHERE u_name LIKE &#39;k_&#39; 3、[ ]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。SELECT * FROM [user] WHERE u_name LIKE &#39;[赵钱孙李]小明&#39; 4、[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。SELECT * FROM [user] WHERE u_name LIKE &#39;[^赵钱孙李]小明&#39; 定义转义字符，以去掉特殊字符的特定含义，使其被作为普通字符看待。可用\%去匹配 %，用\＿去匹配＿，用\ \去匹配 \LIKE &#39;DB\ Design&#39; ESCAPE &#39;\&#39;ESCAPE ‘＼’ 表示“ ＼” 为换码字符 order by排序order by 列名 [asc | desc]; 可以按一个或多个属性列排序升序：ASC 降序：DESC 缺省值为升序 聚集函数：计数 COUNT（[DISTINCT|ALL] *） COUNT（[DISTINCT|ALL] &lt;列名&gt;）计算总和 SUM（[DISTINCT|ALL] &lt;列名&gt;）计算平均值 AVG（[DISTINCT|ALL] &lt;列名&gt;）最大值 MAX（[DISTINCT|ALL] &lt;列名&gt;） &gt;最小值 MIN（[DISTINCT|ALL] &lt;列名例:计算1号课程的学生平均成绩。SELECT AVG(Grade) FROM SC WHERE Cno= &#39; 1 &#39;; group by分组group by 列名 [having 条件表达式]group by将表中的元组按指定一列或多列上的值相等的 原则分组，然后在每一分组上使用聚集函数，得到单一值。having则对分组进行选择，只将聚集函数作用到满足条件的分组上。例：列出所有课程均及格 的学生的平均成绩。 select SNO，avg(SCORE) from SC group by SNO having min(SCORE) &gt;= 60 连接查询自然连接：两个表有同名的属性，此属性值相等的元组相连例: SELECT S.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade FROM S，SC WHERE S.Sno = SC.Sno 自身连接：一个表与其自己进行连接,需要给表起别名以示区别,由于所有属性名都是同名属性，因此必须使用别名前缀例:查询每一门课的间接先修课（即先修课的先修课） SELECT FIRST.Cno，SECOND.Cpno FROM Course FIRST，Course SECOND WHERE FIRST.Cpno = SECOND.Cno 外连接:自然连接时，可能会有信息因为失配而在结果中丢失，为避免丢失，可以假定往另一个参与连接的表中附加一个取值全为空值的行，失配的行会和空值行匹配，不至于丢失，称之为外连接。 外连接 = 自然连接 + 失配的元组例:查询每个学生及其选修课程的情况 SELECT Student.Sno，Sname，Ssex，Sage，Sdept，Cno，Grade FROM Student LEFT OUT JOIN SC ON (Student.Sno=SC.Sno); 复合条件连接：WHERE子句中含多个连接条件例： SELECT S.Sno，Sname，Cname，Grade FROM S，SC，Course /*多表连接*/ WHERE S.Sno = SC.Sno and SC.Cno = Course.Cno; FROM S，SC，Course三者做相当于笛卡尔积嵌套查询不相关子查询：子查询的查询条件不依赖于父查询，由里向外 逐层处理。即每个子查询在上一级查询处理 之前求解，子查询的结果用于建立其父查询的查找条件。相关子查询：子查询的查询条件依赖于父查询，首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE子句返回值为真，则取此元组放入结果表 然后再取外层表的下一个元组重复这一过程，直至外层表全部检查完为止。（有点像for循环） 不相关例子：查询与“刘晨”在同一个系学习的学生 SELECT Sno，Sname，Sdept FROM Student WHERE Sdept IN (SELECT Sdept FROM Student WHERE Sname= ‘ 刘晨 ’); 相关例子：找出每个学生超过他选修课程平均成绩的课程号。 SELECT Sno,Cno FROM SC x /*更名 as可省略*/ WHERE Grade &gt;=(SELECT AVG(Grade) FROM SC y WHERE y.Sno=x.Sno); 带有ANY（SOME）或ALL谓词的子查询ANY：任意一个值ALL：所有值格式为：表达式 比较运算符 ANY|ALL （子查询）例：查询其他系中比计算机科学系所有学生年龄都小 的学生姓名及年龄。 SELECT Sname，Sage FROM S WHERE Sage &lt; ALL (SELECT Sage FROM S WHERE Sdept= &apos; CS &apos;) AND Sdept &lt;&gt; &apos; CS ’; 带有EXISTS谓词的子查询例：查询所有选修了1号课程的学生姓名。 SELECT Sname FROM S WHERE EXISTS (SELECT * FROM SC WHERE Sno=S.Sno AND Cno= &apos; 1 &apos;);]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
